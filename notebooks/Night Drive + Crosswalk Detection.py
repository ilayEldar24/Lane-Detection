# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l1CpJ0C9SeTF-GrU7nTf3phxbex3RlKO
"""

from google.colab import drive
from google.colab import files
from google.colab.patches import cv2_imshow
import os
import numpy as np


# Mount Google Drive
drive.mount('/content/drive')

# Define the filename
video_filename = 'Crosswalk.mp4'


video_path = '/content/drive/My Drive/' + video_filename

if os.path.exists(video_path):
    print(f"{video_filename} exists in your Google Drive.")
else:
    print(f"{video_filename} not found in your Google Drive. Please make sure the file is uploaded to your Drive.")

# If the file exists in Google Drive, Copying into colab enviorment
if os.path.exists(video_path):
    # Copy the video file to the Colab working directory
    !cp "{video_path}" "./{video_filename}"
    print(f"{video_filename} has been copied to the Colab environment.")
else:
    print(f"File {video_filename} not found in your Google Drive. Please upload it to your Drive or provide the correct file path.")

import cv2

# Define the video filename
video_filename = 'Crosswalk.mp4'

# Open the video file
cap = cv2.VideoCapture(video_filename)

# Check if the video opened successfully
if not cap.isOpened():
    print("Error: Could not open video.")
else:
    print("Video opened successfully.")

# Open the video file again
cap = cv2.VideoCapture('Crosswalk.mp4')

# Determine the video's frame rate
fps = cap.get(cv2.CAP_PROP_FPS)

# Calculate the number of frames to capture for 5 seconds
duration_seconds = 25
frames_count = int(duration_seconds * fps)

# Read and store frames from the video
frames = []
for i in range(frames_count):
    ret, frame = cap.read()
    if not ret:
        break
    frames.append(frame)

cap.release()  # Release the video capture object

# Save the 5-second clip as a new video
fourcc = cv2.VideoWriter_fourcc(*'MP4V')
out = cv2.VideoWriter('5_sec_clip.mp4', fourcc, fps, (frames[0].shape[1], frames[0].shape[0]))
for frame in frames:
    out.write(frame)
out.release()

def make_points(image, average):
 slope, y_int = average
 y1 = image.shape[0]
 y2 = int(y1 * (3/5))
 x1 = int((y1 - y_int) // slope)
 x2 = int((y2 - y_int) // slope)
 return np.array([x1, y1, x2, y2])

def average(image, lines):
    left = []
    right = []
    if lines is None or len(lines) == 0:  # Check if lines is None or empty
        right_avg = np.array([0, 0])
        left_avg = np.array([0, 0])
        return np.array([right_avg, left_avg])

    for line in lines:
        print(line)
        x1, y1, x2, y2 = line.reshape(4)
        parameters = np.polyfit((x1, x2), (y1, y2), 1)
        slope = parameters[0]
        y_int = parameters[1]
        if slope < 0:
            left.append((slope, y_int))
        else:
            right.append((slope, y_int))
    if right:
        right_avg = np.average(right, axis=0)
    else:
        right_avg = np.array([0, 0])
        left_avg = np.array([0, 0])
        return np.array([right_avg, left_avg])

    if left:
        left_avg = np.average(left, axis=0)
    else:
        right_avg = np.array([0, 0])
        left_avg = np.array([0, 0])
        return np.array([right_avg, left_avg])

    left_line = make_points(image, left_avg)
    right_line = make_points(image, right_avg)
    return np.array([left_line, right_line])


def roi_mask(image):
    height, width = image.shape[:2]

    # Calculate the height of the polygon
    mid_x, mid_y = width // 2, height // 2

# Region of interest (ROI) vertices for a pentagon
    roi_vertices = np.array([
        [width*0.7, int(height * 0.85)],    # Bottom right (just above the cut)
        [mid_x*0.95, mid_y*1.1],                 # Middle of the image
        [width*0.2, int(height * 0.85)]         # Bottom left (just above the cut)
    ], dtype=np.int32)

    # Create a mask for the region of interest (ROI)
    roi_mask = np.zeros_like(image)
    # Fill the pentagon on the mask
    roi_mask = cv2.fillPoly(roi_mask, [roi_vertices], 255)
    return roi_mask


def roi_mask_for_crosswalk(image):
    height, width = image.shape[:2]

    # Calculate the height of the polygon
    mid_x, mid_y = width // 2, height // 2

# Region of interest (ROI) vertices for a pentagon
    roi_vertices = np.array([
        [width*0.65, int(height * 0.85)],    # Bottom right (just above the cut)
        [mid_x*0.95, mid_y*1.15],                 # Middle of the image
        [width*0.27, int(height * 0.85)]         # Bottom left (just above the cut)
    ], dtype=np.int32)

    # Create a mask for the region of interest (ROI)
    roi_mask = np.zeros_like(image)
    # Fill the pentagon on the mask
    roi_mask = cv2.fillPoly(roi_mask, [roi_vertices], 255)
    return roi_mask

def display_lines(image, lines):
 lines_image = np.zeros_like(image)
 if lines is not None:
   for line in lines:
     x1, y1, x2, y2 = line
     cv2.line(lines_image, (x1, y1), (x2, y2), (255, 0, 0), 10)
 return lines_image



def detect_squares_in_mask(mask):
    # Create a blank image of the same dimensions as the mask, filled with zeros
    squares_image = np.zeros(mask.shape, dtype=np.uint8)

    # Find contours in the masked image
    contours, _ = cv2.findContours(mask, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
    print(f"Total contours found: {len(contours)}")  # Debugging: Check how many contours are found
    top_height = bottom_height = 0
    for cnt in contours:
        # Approximate the contour to a polygon
        approx = cv2.approxPolyDP(cnt, 0.02*cv2.arcLength(cnt, True), True)

        # Check if the approximated contour has 4 sides (indicating it could be a square)
        if len(approx) == 4:
            # Optionally, check if the contour is reasonably large to filter out noise
            area = cv2.contourArea(cnt)
            if area > 1000:  # The area threshold is adjustable based on your specific needs
                _, y, _, h = cv2.boundingRect(approx)
                top_height = y
                bottom_height = y + h
                return top_height,bottom_height

    return top_height,bottom_height




def paint_area_between_heights(frame, top, bottom, lane_mask):
    # Assuming lane_mask is a binary mask compatible in size with frame's height and width
    height_mask = np.zeros_like(frame[:, :, 0])  # Create a single-channel mask of zeros
    height_mask[top:bottom, :] = 1  # Set the mask to 1 in the desired range

    # Ensure lane_mask is a single-channel binary mask for bitwise operations
    if len(lane_mask.shape) == 3 and lane_mask.shape[2] == 3:
        lane_mask = cv2.cvtColor(lane_mask, cv2.COLOR_BGR2GRAY)

    combined_mask = cv2.bitwise_and(height_mask, lane_mask)
    combined_mask = combined_mask.astype(bool)  # Convert to a boolean mask for indexing

    # Use np.where to apply the mask across all color channels
    frame[combined_mask] = [128, 0, 128]  # Paint in green

    return frame

copy = np.copy(frames[110])

gray = cv2.cvtColor(copy, cv2.COLOR_BGR2GRAY)

blurred = cv2.GaussianBlur(gray, (5,5), 0)

edges = cv2.Canny(blurred, 30, 120)

mask = roi_mask(edges)

masked_image = cv2.bitwise_and(edges, mask)

lines = cv2.HoughLinesP(masked_image, 6, np.pi/60, threshold=160, minLineLength=40, maxLineGap=25)

averaged_lines = average(masked_image, lines)

black_lines = display_lines(copy, averaged_lines)

lanes = cv2.addWeighted(copy, 0.8, black_lines, 1, 1)

cv2_imshow(lanes)

mask_crosswalk =roi_mask_for_crosswalk(edges)
masked_crosswalk = cv2.bitwise_and(edges, mask_crosswalk)
top, bottom = detect_squares_in_mask(masked_crosswalk)
out_frame = paint_area_between_heights(lanes,top,bottom,mask)
cv2_imshow(out_frame)

# Initialize video writer
output_filename = 'annotated_20_sec_clip.mp4'
out = cv2.VideoWriter(output_filename, fourcc, fps, (frames[0].shape[1], frames[0].shape[0]))
previous_lanes = None

for frame in frames:
    copy = np.copy(frame)
    gray = cv2.cvtColor(copy, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (5,5), 0)
    edges = cv2.Canny(blurred, 30, 120)
    mask = roi_mask(edges)
    masked_image = cv2.bitwise_and(edges, mask)
    lines = cv2.HoughLinesP(masked_image, 6, np.pi/60, threshold=160, minLineLength=30, maxLineGap=25)
    averaged_lines = average(masked_image, lines)

    # Check if averaged_lines contains [0, 0, 0, 0] indicating no line was found
    if np.array_equal(averaged_lines[0], [0, 0]) or np.array_equal(averaged_lines[1], [0, 0]):
        out.write(copy)  # Write the original frame if no lines are detected
        continue

    black_lines = display_lines(copy, averaged_lines)
    lanes = cv2.addWeighted(copy, 0.8, black_lines, 1, 1)

    mask_crosswalk =roi_mask_for_crosswalk(edges)
    masked_crosswalk = cv2.bitwise_and(edges, mask_crosswalk)
    top, bottom = detect_squares_in_mask(masked_crosswalk)
    if(top != 0 and bottom != 0):
      lanes = paint_area_between_heights(lanes,top,bottom,mask)

    out.write(lanes)


# Release everything when job is finished
out.release()

print("Video processing is complete. The video has been saved to the Colab environment.")

# Use the 'files.download' function to prompt the browser to download the file to your local machine
files.download('annotated_20_sec_clip.mp4')