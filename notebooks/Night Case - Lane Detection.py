# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZPVK28LIUIEg62pdzJj-obq-VMLa2O4J
"""

from google.colab import drive
from google.colab import files
from google.colab.patches import cv2_imshow
import os
import numpy as np


# Mount Google Drive
drive.mount('/content/drive')

# Define the filename
video_filename = 'Night Drive.mp4'


video_path = '/content/drive/My Drive/' + video_filename

if os.path.exists(video_path):
    print(f"{video_filename} exists in your Google Drive.")
else:
    print(f"{video_filename} not found in your Google Drive. Please make sure the file is uploaded to your Drive.")

# If the file exists in Google Drive, Copying into colab enviorment
if os.path.exists(video_path):
    # Copy the video file to the Colab working directory
    !cp "{video_path}" "./{video_filename}"
    print(f"{video_filename} has been copied to the Colab environment.")
else:
    print(f"File {video_filename} not found in your Google Drive. Please upload it to your Drive or provide the correct file path.")

import cv2

# Define the video filename
video_filename = 'Night Drive.mp4'

# Open the video file
cap = cv2.VideoCapture(video_filename)

# Check if the video opened successfully
if not cap.isOpened():
    print("Error: Could not open video.")
else:
    print("Video opened successfully.")

# Open the video file again
cap = cv2.VideoCapture('Night Drive.mp4')

# Determine the video's frame rate
fps = cap.get(cv2.CAP_PROP_FPS)

# Calculate the number of frames to capture for 5 seconds
duration_seconds = 25
frames_count = int(duration_seconds * fps)

# Read and store frames from the video
frames = []
for i in range(frames_count):
    ret, frame = cap.read()
    if not ret:
        break
    frames.append(frame)

cap.release()  # Release the video capture object

# Save the 5-second clip as a new video
fourcc = cv2.VideoWriter_fourcc(*'MP4V')
out = cv2.VideoWriter('5_sec_clip.mp4', fourcc, fps, (frames[0].shape[1], frames[0].shape[0]))
for frame in frames:
    out.write(frame)
out.release()

def roi_mask(image):
    height, width = image.shape[:2]

    # Calculate the height of the polygon
    mid_x, mid_y = width // 2, height // 2

# Region of interest (ROI) vertices for a pentagon
    roi_vertices = np.array([
        [width* 0.8, int(height * 0.85)],    # Bottom right (just above the cut)
        [mid_x*0.90, mid_y*1.25],                 # Middle of the image
        [width* 0.1, int(height * 0.85)]         # Bottom left (just above the cut)
    ], dtype=np.int32)

    # Create a mask for the region of interest (ROI)
    roi_mask = np.zeros_like(image)
    # Fill the pentagon on the mask
    roi_mask = cv2.fillPoly(roi_mask, [roi_vertices], 255)
    return roi_mask

def make_points(image, average):
 slope, y_int = average
 y1 = image.shape[0]
 y2 = int(y1 * (3/5))
 x1 = int((y1 - y_int) // slope)
 x2 = int((y2 - y_int) // slope)
 return np.array([x1, y1, x2, y2])

def average(image, lines):
    left = []
    right = []
    if lines is None or len(lines) == 0:  # Check if lines is None or empty
        right_avg = np.array([0, 0])
        left_avg = np.array([0, 0])
        return np.array([right_avg, left_avg])

    for line in lines:
        print(line)
        x1, y1, x2, y2 = line.reshape(4)
        parameters = np.polyfit((x1, x2), (y1, y2), 1)
        slope = parameters[0]
        y_int = parameters[1]
        if slope < 0:
            left.append((slope, y_int))
        else:
            right.append((slope, y_int))
    if right:
        right_avg = np.average(right, axis=0)
    else:
        right_avg = np.array([0, 0])
        left_avg = np.array([0, 0])
        return np.array([right_avg, left_avg])

    if left:
        left_avg = np.average(left, axis=0)
    else:
        right_avg = np.array([0, 0])
        left_avg = np.array([0, 0])
        return np.array([right_avg, left_avg])

    left_line = make_points(image, left_avg)
    right_line = make_points(image, right_avg)
    return np.array([left_line, right_line])

def display_lines(image, lines):
    lines_image = np.zeros_like(image)
    if lines is not None:
        for line in lines:
            x1, y1, x2, y2 = line
            # Calculate midpoint
            mid_x = (x1 + x2) // 2
            mid_y = (y1 + y2) // 2
            # Calculate new endpoints
            new_x1 = int(mid_x + 0.7 * (x1 - mid_x))
            new_y1 = int(mid_y + 0.7 * (y1 - mid_y))
            new_x2 = int(mid_x + 0.7 * (x2 - mid_x))
            new_y2 = int(mid_y + 0.7 * (y2 - mid_y))
            cv2.line(lines_image, (new_x1, new_y1), (new_x2, new_y2), (255, 0, 0), 10)
    return lines_image

copy = np.copy(frames[0])

gray = cv2.cvtColor(copy, cv2.COLOR_BGR2GRAY)

blurred = cv2.GaussianBlur(gray, (5,5), 0)

edges = cv2.Canny(blurred, 30, 120)

mask = roi_mask(edges)

masked_image = cv2.bitwise_and(edges, mask)

lines = cv2.HoughLinesP(masked_image, 6, np.pi/60, threshold=160, minLineLength=40, maxLineGap=25)

averaged_lines = average(masked_image, lines)

black_lines = display_lines(copy, averaged_lines)

lanes = cv2.addWeighted(copy, 0.8, black_lines, 1, 1)

cv2_imshow(lanes)

# Initialize video writer
output_filename = 'Night Drive Detected.mp4'
out = cv2.VideoWriter(output_filename, fourcc, fps, (frames[0].shape[1], frames[0].shape[0]))
previous_lanes = None

for frame in frames:
    copy = np.copy(frame)
    gray = cv2.cvtColor(copy, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (5,5), 0)
    edges = cv2.Canny(blurred, 30, 120)
    mask = roi_mask(edges)
    masked_image = cv2.bitwise_and(edges, mask)
    lines = cv2.HoughLinesP(masked_image, 6, np.pi/60, threshold=160, minLineLength=30, maxLineGap=25)
    averaged_lines = average(masked_image, lines)

    # Check if averaged_lines contains [0, 0, 0, 0] indicating no line was found
    if np.array_equal(averaged_lines[0], [0, 0]) or np.array_equal(averaged_lines[1], [0, 0]):
        out.write(copy)  # Write the original frame if no lines are detected
        continue

    black_lines = display_lines(copy, averaged_lines)
    lanes = cv2.addWeighted(copy, 0.8, black_lines, 1, 1)
    out.write(lanes)


# Release everything when job is finished
out.release()

print("Video processing is complete. The video has been saved to the Colab environment.")

# Use the 'files.download' function to prompt the browser to download the file to your local machine
files.download('Night Drive Detected.mp4')